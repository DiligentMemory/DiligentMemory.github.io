<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java基础概述 | 程序咖啡屋</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/favicon.ico">
    <script>
        var _hmt = _hmt || [];
          (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?5a16afb5272fc443793a34edbb191223";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
          })();</script>
    <meta name="description" content=" ">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.41e46469.css" as="style"><link rel="preload" href="/assets/js/app.b6f48787.js" as="script"><link rel="preload" href="/assets/js/7.ec9bc4d0.js" as="script"><link rel="preload" href="/assets/js/2.0c7886bd.js" as="script"><link rel="preload" href="/assets/js/1.8f3833ee.js" as="script"><link rel="preload" href="/assets/js/39.991d6637.js" as="script"><link rel="prefetch" href="/assets/js/10.f07b9d93.js"><link rel="prefetch" href="/assets/js/11.aedf7da4.js"><link rel="prefetch" href="/assets/js/14.916cb05d.js"><link rel="prefetch" href="/assets/js/15.d2ca7161.js"><link rel="prefetch" href="/assets/js/16.1d522888.js"><link rel="prefetch" href="/assets/js/17.2e659a4d.js"><link rel="prefetch" href="/assets/js/18.34c83be0.js"><link rel="prefetch" href="/assets/js/19.c3b5106c.js"><link rel="prefetch" href="/assets/js/20.8c72a05c.js"><link rel="prefetch" href="/assets/js/21.988faded.js"><link rel="prefetch" href="/assets/js/22.ad121b6e.js"><link rel="prefetch" href="/assets/js/23.737b3f7d.js"><link rel="prefetch" href="/assets/js/24.1a965937.js"><link rel="prefetch" href="/assets/js/25.c6c69c96.js"><link rel="prefetch" href="/assets/js/26.41565a57.js"><link rel="prefetch" href="/assets/js/27.ce6a8795.js"><link rel="prefetch" href="/assets/js/28.929a98ba.js"><link rel="prefetch" href="/assets/js/29.85cdba7a.js"><link rel="prefetch" href="/assets/js/3.6ea7db73.js"><link rel="prefetch" href="/assets/js/30.c90c4bbc.js"><link rel="prefetch" href="/assets/js/31.aa085ec1.js"><link rel="prefetch" href="/assets/js/32.fa884116.js"><link rel="prefetch" href="/assets/js/33.8ba5d925.js"><link rel="prefetch" href="/assets/js/34.28bf7738.js"><link rel="prefetch" href="/assets/js/35.9a6f067b.js"><link rel="prefetch" href="/assets/js/36.ae5fa301.js"><link rel="prefetch" href="/assets/js/37.8bc0bf7a.js"><link rel="prefetch" href="/assets/js/38.efe0ec45.js"><link rel="prefetch" href="/assets/js/4.89f90316.js"><link rel="prefetch" href="/assets/js/40.df4a9cc6.js"><link rel="prefetch" href="/assets/js/41.2123a88d.js"><link rel="prefetch" href="/assets/js/42.f784a0f3.js"><link rel="prefetch" href="/assets/js/43.7b51a092.js"><link rel="prefetch" href="/assets/js/44.74c7afa3.js"><link rel="prefetch" href="/assets/js/45.c70512b8.js"><link rel="prefetch" href="/assets/js/46.9c1223a5.js"><link rel="prefetch" href="/assets/js/47.2af81677.js"><link rel="prefetch" href="/assets/js/48.0618d55d.js"><link rel="prefetch" href="/assets/js/49.2076ec88.js"><link rel="prefetch" href="/assets/js/5.4683e3fa.js"><link rel="prefetch" href="/assets/js/6.f0e0fc80.js"><link rel="prefetch" href="/assets/js/8.77d757b7.js"><link rel="prefetch" href="/assets/js/9.81c499b5.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5164d387.js">
    <link rel="stylesheet" href="/assets/css/0.styles.41e46469.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>程序咖啡屋</h3> <p class="description" data-v-59e6cb88> </p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>Luke</span>
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="程序咖啡屋" class="logo"> <span class="site-name">程序咖啡屋</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/后端开发/" class="nav-link"><i class="undefined"></i>
  后端开发
</a></li><li class="dropdown-item"><!----> <a href="/categories/MySQL/" class="nav-link"><i class="undefined"></i>
  MySQL
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/avatar.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    Luke
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>11</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>4</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/后端开发/" class="nav-link"><i class="undefined"></i>
  后端开发
</a></li><li class="dropdown-item"><!----> <a href="/categories/MySQL/" class="nav-link"><i class="undefined"></i>
  MySQL
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      Contact
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/recoluan" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>Java基础概述</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>Luke</span>
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">Java基础概述</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>Luke</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>11/14/2023</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>Java</span></i></div></div> <div class="theme-reco-content content__default"><div class="custom-block theorem"><p class="title"></p><p>本篇文章将介绍Java语言的基础语法，包括面向对象、关键字、IO流以及反射等概念。</p></div> <h2 id="java概述"><a href="#java概述" class="header-anchor">#</a> Java概述</h2> <h3 id="何为编程"><a href="#何为编程" class="header-anchor">#</a> 何为编程</h3> <ul><li>编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。</li> <li>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</li></ul> <h3 id="什么是java"><a href="#什么是java" class="header-anchor">#</a> 什么是Java</h3> <p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</p> <h3 id="jdk1-5之后的三大版本"><a href="#jdk1-5之后的三大版本" class="header-anchor">#</a> jdk1.5之后的三大版本</h3> <ul><li>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）</li> <li>Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li> <li>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）</li> <li>Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</li> <li>Java ME（J2ME，Java 2 Platform Micro Edition，微型版） Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li></ul> <h3 id="jdk和jre和jvm的区别"><a href="#jdk和jre和jvm的区别" class="header-anchor">#</a> JDK和JRE和JVM的区别</h3> <blockquote><p>看Java官方的图片，Jdk中包括了Jre，Jre中包括了JVM</p></blockquote> <ul><li>JDK ：Jdk还包括了一些Jre之外的东西 ，就是这些东西帮我们编译Java代码的， 还有就是监控Jvm的一些工具 Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</li> <li>JRE ：Jre大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库 Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</li></ul> <p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p> <ul><li>Jvm：在倒数第二层 由他可以在（最后一层的）各种平台上运行 Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</li></ul> <p><img src="https://blog-images-luke.oss-cn-shanghai.aliyuncs.com/test/202311071439035.png" alt="image.png"></p> <h3 id="什么是跨平台性-原理是什么"><a href="#什么是跨平台性-原理是什么" class="header-anchor">#</a> 什么是跨平台性？原理是什么</h3> <ul><li>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</li> <li>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</li></ul> <h3 id="java语言有哪些特点"><a href="#java语言有哪些特点" class="header-anchor">#</a> Java语言有哪些特点</h3> <ul><li>简单易学（Java语言的语法与C语言和C++语言很接近）</li> <li>面向对象（封装，继承，多态）</li> <li>平台无关性（Java虚拟机实现平台无关性）</li> <li>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</li> <li>支持多线程（多线程机制使应用程序在同一时间并行执行多项任）</li> <li>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</li> <li>安全性好</li></ul> <h3 id="什么是字节码-采用字节码的最大好处是什么"><a href="#什么是字节码-采用字节码的最大好处是什么" class="header-anchor">#</a> 什么是字节码？采用字节码的最大好处是什么</h3> <ul><li><strong>字节码</strong>：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</li> <li><strong>采用字节码的好处</strong>：Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</li> <li><strong>先看下java中的编译器和解释器</strong>：Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。</li> <li>Java源代码----&gt;编译器----&gt;jvm可执行的Java字节码(即虚拟指令)----&gt;jvm----&gt;jvm中解释器-----&gt;机器可执行的二进制机器码----&gt;程序运行。</li></ul> <h3 id="什么是java程序的主类-应用程序和小程序的主类有何不同"><a href="#什么是java程序的主类-应用程序和小程序的主类有何不同" class="header-anchor">#</a> 什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3> <p>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</p> <h3 id="java应用程序与小程序之间有那些差别"><a href="#java应用程序与小程序之间有那些差别" class="header-anchor">#</a> Java应用程序与小程序之间有那些差别？</h3> <p>简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</p> <h3 id="java和c-的区别"><a href="#java和c-的区别" class="header-anchor">#</a> Java和C++的区别</h3> <ul><li>都是面向对象的语言，都支持封装、继承和多态</li> <li>Java不提供指针来直接访问内存，程序内存更加安全</li> <li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li> <li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul> <h3 id="oracle-jdk-和-openjdk-的对比"><a href="#oracle-jdk-和-openjdk-的对比" class="header-anchor">#</a> Oracle JDK 和 OpenJDK 的对比</h3> <ol><li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</li> <li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</li> <li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</li> <li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</li> <li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li> <li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li></ol> <h2 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h2> <h3 id="什么是面向对象"><a href="#什么是面向对象" class="header-anchor">#</a> 什么是面向对象</h3> <p>面向对象程序设计是以建立模型体现出来的抽象思维过程和面向对象的方法。我们可以将某个事物抽象 出来，赋予它自己的特征，并且可以针对这个事物进行相应的操作，以及规定与其他对象之间的关系。 可以降低代码的耦合度，使程序更加灵活。</p> <h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="header-anchor">#</a> 面向对象和面向过程的区别</h3> <p><strong>面向过程：</strong></p> <ul><li><strong>优点</strong>：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式 开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li> <li><strong>缺点</strong>：没有面向对象易维护、易复用、易扩展。</li></ul> <p><strong>面向对象：</strong></p> <ul><li>**优点：**易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系 统，使系统更加灵活、更加易于维护。</li> <li>**缺点：**性能比面向过程低。</li></ul> <p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。
面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p> <h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="header-anchor">#</a> 面向对象的三大特性</h3> <ul><li><strong>封装：</strong></li></ul> <p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。
封装隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。</p> <ul><li><strong>继承：</strong></li></ul> <p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。
关于继承如下 3 点请记住：</p> <div class="language- extra-class"><pre><code>  1.  子类拥有父类非 private 的属性和方法。 
  2.  子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 
  3.  子类可以用自己的方式实现父类的方法。 
</code></pre></div><ul><li><strong>多态：</strong></li></ul> <p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出 的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
在Java中有两种形式可以实现多态：</p> <ul><li>继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</li></ul> <p>方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是 运行时的多态性（也称为后绑定）。</p> <p>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法， 必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：</p> <ul><li>方法重写（子类继承父类并重写父类中已有的或抽象的方法）；</li> <li>对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而 表现出不同的行为）。</li></ul> <h3 id="面向对象的五大基本原则"><a href="#面向对象的五大基本原则" class="header-anchor">#</a> 面向对象的五大基本原则</h3> <ul><li><strong>单一职责原则SRP</strong>(Single Responsibility Principle) ：类的功能要单一，不能包罗万象，跟杂货铺似的。</li> <li><strong>开放封闭原则OCP</strong>(Open－Close Principle) ：一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，一万个不乐意。</li> <li><strong>里式替换原则LSP</strong>(the Liskov Substitution Principle LSP) ：子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li> <li><strong>依赖倒置原则DIP</strong>(the Dependency Inversion Principle DIP) ：高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现， 具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li> <li><strong>接口分离原则ISP</strong>(the Interface Segregation Principle ISP) ：设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li></ul> <h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="header-anchor">#</a> 值传递和引用传递</h3> <ul><li><strong>值传递</strong>，是对基本数据类型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</li> <li><strong>引用传递</strong>，一般是对于对象数据类型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。 一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递。</li></ul> <h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="header-anchor">#</a> 接口和抽象类的区别</h3> <table><thead><tr><th><strong>比较</strong></th> <th><strong>抽象类</strong></th> <th><strong>接口</strong></th></tr></thead> <tbody><tr><td>默认方法</td> <td>抽象类可以有默认的方法实现</td> <td>Java8之前，不存在方法的实现</td></tr> <tr><td>实现方式</td> <td>子类使用extends关键字来继承抽象类。如果子类不是抽象类，子类需要提供抽象类中所声明方法的实现</td> <td>子类使用implements来实现接口，需要提供接口所有声明的实现</td></tr> <tr><td>构造器</td> <td>抽象类中可以有构造器</td> <td>接口中不能</td></tr> <tr><td>访问修饰符</td> <td>抽象方法可以有public，protected和default等修饰</td> <td>接口默认是public，不能使用其他修饰符</td></tr> <tr><td>多继承</td> <td>一个子类只能存在一个父类</td> <td>一个子类可以存在多个接口</td></tr> <tr><td>访问新方法</td> <td>向抽象类中添加新方法，可以提供默认的实现，因此可以不修饰子类现有的代码</td> <td>如果往接口中添加新方法，则子类中需要实现该方法</td></tr></tbody></table> <h3 id="父类的静态方法能否被子类重写"><a href="#父类的静态方法能否被子类重写" class="header-anchor">#</a> 父类的静态方法能否被子类重写</h3> <p>不能。重写只适用于实例方法,不能用于静态方法，而子类当中含有和父类相同签名的静态方法，我们一
般称之为隐藏。</p> <h3 id="什么是不可变对象"><a href="#什么是不可变对象" class="header-anchor">#</a> 什么是不可变对象</h3> <p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、 Integer及其它包装类。</p> <h3 id="静态变量和实例变量的区别"><a href="#静态变量和实例变量的区别" class="header-anchor">#</a> 静态变量和实例变量的区别</h3> <p>静态变量存储在方法区，属于类所有。实例变量存储在堆当中，其引用存在当前线程栈。</p> <h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="header-anchor">#</a> 重写和重载的区别</h3> <p>方法的重写Overriding和重载Overloading是Java多态性的不同表现。
重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。
如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。</p> <h2 id="基本数据类型"><a href="#基本数据类型" class="header-anchor">#</a> 基本数据类型</h2> <h3 id="java基本数据类型"><a href="#java基本数据类型" class="header-anchor">#</a> Java基本数据类型</h3> <p><img src="https://blog-images-luke.oss-cn-shanghai.aliyuncs.com/test/202311071439145.png" alt="image.png"></p> <h3 id="switch用法"><a href="#switch用法" class="header-anchor">#</a> switch用法</h3> <p>switch结合case，能够判断一个变量或表达式与一系列值中的某个值是否相等，这里的每个值都被称为一个分支。<strong>switch语句在执行时，会先进行值的匹配，匹配成功时会进入到对应case语句。再根据是否有 break语句，判断是否继续输出，或是跳出当前switch判断。</strong>
switch(值)语句中的”值“，支持的类型（目前是不支持long的）有如下几类：</p> <ul><li><strong>整型：byte、short、int 、char及其对应的包装类；</strong></li> <li><strong>枚举类型，从JDK 5开始支持(后面壹哥会详细讲解枚举类型)；</strong></li> <li><strong>String类型，从JDK 7开始支持，同时case标签后的值必须是字符串常量或字面量。</strong></li> <li>switch后面可以有多个 case 语句，每个 case 后都要跟一个待比较的值和冒号。</li> <li>case标签后面值的数据类型必须与switch(值)中的数据类型相同，且只能是常量或者字面常量。</li> <li>当switch(值)的值与 case语句中的值相等时，case标签后面的语句开始执行，遇到break标签时停止执行switch语句。</li> <li><strong>case语句中不一定非要带有break语句。如果case后没有 break 语句，程序会继续执行下一个case 语句，直到出现 break 语句，这种现象叫做”case穿透“。</strong></li> <li>switch语句中可以包含一个default默认分支，该分支一般是 switch 语句的最后一个分支，当switch的值和case语句的值不相等时执行。default 分支中不用带有break 语句，另外该分支可以放在任何位置，但建议写在最后面。</li></ul> <h3 id="math-round用法"><a href="#math-round用法" class="header-anchor">#</a> Math.round用法</h3> <ul><li><code>Math.round(11.5)</code>的返回值是 12，<code>Math.round(-11.5)</code>的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。</li></ul> <h3 id="float用法"><a href="#float用法" class="header-anchor">#</a> float用法</h3> <p>float f=3.4;是否正确
不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（downcasting，也称为窄化）会造成精度损失，因此需要强制类型转换<code>float f =(float)3.4</code>; 或者写成 <code>float f = 3.4F;</code>。</p> <h3 id="short用法"><a href="#short用法" class="header-anchor">#</a> short用法</h3> <blockquote><p>short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗</p></blockquote> <p>对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。
而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。</p> <h2 id="访问修饰符"><a href="#访问修饰符" class="header-anchor">#</a> 访问修饰符</h2> <ul><li><strong>定义</strong>：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</li> <li><strong>分类</strong> <ul><li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li> <li>default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li> <li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li> <li>public : 对所有类可见。使用对象：类、接口、变量、方法</li></ul></li> <li><strong>访问修饰符图</strong></li></ul> <table><thead><tr><th><strong>修饰符</strong></th> <th><strong>当前类</strong></th> <th><strong>同包</strong></th> <th><strong>子类</strong></th> <th><strong>其他包</strong></th></tr></thead> <tbody><tr><td>private</td> <td>✔️</td> <td>❌</td> <td>❌</td> <td>❌</td></tr> <tr><td>default</td> <td>✔️</td> <td>✔️</td> <td>❌</td> <td>❌</td></tr> <tr><td>protected</td> <td>✔️</td> <td>✔️</td> <td>✔️</td> <td>❌</td></tr> <tr><td>public</td> <td>✔️</td> <td>✔️</td> <td>✔️</td> <td>✔️</td></tr></tbody></table> <h2 id="关键字"><a href="#关键字" class="header-anchor">#</a> 关键字</h2> <h3 id="final-finally和finalize区别"><a href="#final-finally和finalize区别" class="header-anchor">#</a> final，finally和finalize区别</h3> <p><strong>final：用于修饰类，属性和方法；</strong></p> <ul><li>被final修饰的类不可以被继承</li> <li>被final修饰的方法不可以被重写</li> <li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul> <p><strong>区别：</strong></p> <ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表 示该变量是一个常量不能被重新赋值。</li> <li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法，finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li> <li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调 用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的 最后判断。</li></ul> <h3 id="this用法"><a href="#this用法" class="header-anchor">#</a> this用法</h3> <ul><li>this是自身的一个对象，代表对象本身，可以理解为：<strong>指向对象本身的一个指针</strong>。</li> <li>this的用法在java中大体可以分为3种：
<ol><li>普通的直接引用，this相当于是指向当前对象本身。</li> <li>形参与成员名字重名，用this来区分：</li></ol></li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><ol start="3"><li>引用本类的构造函数</li></ol></li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="super用法"><a href="#super用法" class="header-anchor">#</a> super用法</h3> <ul><li>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</li> <li>super也有三种用法：
<ol><li>普通的直接引用</li></ol></li></ul> <p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p> <div class="language- extra-class"><pre><code>  2. 子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分
</code></pre></div><div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token keyword">protected</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> name1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Child</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Father</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Student</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">&quot;Father&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;Child&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s1<span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><div class="language- extra-class"><pre><code>  3. 引用父类构造函数
</code></pre></div><ul><li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li> <li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li></ul> <h3 id="this与super区别"><a href="#this与super区别" class="header-anchor">#</a> this与super区别</h3> <ul><li>super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li> <li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li> <li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li> <li>super()和this()均需放在构造方法内第一行。</li> <li>尽管可以用this调用一个构造器，但却不能调用两个。</li> <li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li> <li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li></ul> <p>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</p> <h3 id="static的作用"><a href="#static的作用" class="header-anchor">#</a> static的作用</h3> <ul><li>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法</strong>！</li> <li>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照<strong>static块的顺序来执行每个static块，并且只会执行一次</strong>。</li> <li>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</li> <li>被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</li> <li>static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</li> <li>被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li></ul> <p>注：静态只能访问静态。非静态既可以访问非静态的，也可以访问静态的。</p> <h2 id="内部类"><a href="#内部类" class="header-anchor">#</a> 内部类</h2> <h3 id="什么是内部类"><a href="#什么是内部类" class="header-anchor">#</a> 什么是内部类</h3> <ul><li>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。</li></ul> <h3 id="内部类的种类"><a href="#内部类的种类" class="header-anchor">#</a> 内部类的种类</h3> <h4 id="静态内部类"><a href="#静态内部类" class="header-anchor">#</a> 静态内部类</h4> <ul><li>定义在类内部的静态类，就是静态内部类</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> radius <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StaticInner</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;visit outer static variable:&quot;</span> <span class="token operator">+</span> radius<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式， new 外部类.静态内部类() ，如下：</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Outer<span class="token punctuation">.</span>StaticInner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer<span class="token punctuation">.</span>StaticInner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
inner<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="成员内部类"><a href="#成员内部类" class="header-anchor">#</a> 成员内部类</h4> <ul><li>定义在类内部，成员位置上的非静态类，就是成员内部类。</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> radius <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;visit outer static variable:&quot;</span> <span class="token operator">+</span> radius<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;visit outer variable:&quot;</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式 外部类实例.new 内部类() ，如下：</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Outer</span> outer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Outer<span class="token punctuation">.</span>Inner</span> inner <span class="token operator">=</span> outer<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
inner<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="局部内部类"><a href="#局部内部类" class="header-anchor">#</a> 局部内部类</h4> <ul><li>定义在方法中的内部类，就是局部内部类</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> out_a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">STATIC_b</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFunctionClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> inner_c <span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
            <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>out_a<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">STATIC_b</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>inner_c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Inner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inner<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testStaticFunctionClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> d <span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
            <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token comment">// System.out.println(out_a); 编译错误，定义在静态方法中的局部</span>
                类不可以访问外部类的实例变量
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">STATIC_b</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Inner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        inner<span class="token punctuation">.</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><ul><li>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内， new 内部类() ，如下：</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testStaticFunctionClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Inner</span> inner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Inner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="匿名内部类"><a href="#匿名内部类" class="header-anchor">#</a> 匿名内部类</h4> <ul><li>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Service</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;匿名内部类&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//匿名内部类必须继承或实现一个已有的接口</span>
<span class="token keyword">interface</span> <span class="token class-name">Service</span><span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li>除了没有名字，匿名内部类还有以下特点：
<ul><li>匿名内部类必须继承一个抽象类或者实现一个接口。</li> <li>匿名内部类不能定义任何静态成员和静态方法。</li> <li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li> <li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul></li> <li>匿名内部类创建方式：</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">new</span> 类<span class="token operator">/</span>接口<span class="token punctuation">{</span>
<span class="token comment">//匿名内部类实现部分</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="内部类优点和应用场景"><a href="#内部类优点和应用场景" class="header-anchor">#</a> 内部类优点和应用场景</h3> <p><strong>优点：</strong></p> <ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li> <li>内部类不为同一包的其他类所见，具有很好的封装性；</li> <li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li> <li>匿名内部类可以很方便的定义回调。</li></ul> <p><strong>应用场景：</strong></p> <ul><li>一些多算法场合</li> <li>解决一些非面向对象的语句块。</li> <li>适当使用内部类，使得代码更加灵活和富有扩展性。</li> <li>当某个类除了它的外部类，不再被其他的类使用时。</li></ul> <h3 id="局部内部类和匿名内部类访问局部变量的时候-为什么变量必须要加上final"><a href="#局部内部类和匿名内部类访问局部变量的时候-为什么变量必须要加上final" class="header-anchor">#</a> 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h3> <ul><li>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？先看这段代码：</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">outMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> a <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>
            <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</li></ul> <h2 id="重写与重载"><a href="#重写与重载" class="header-anchor">#</a> 重写与重载</h2> <ul><li>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</li> <li><strong>重载</strong>：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。</li> <li><strong>重写</strong>：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</li></ul> <h2 id="对象相等判断"><a href="#对象相等判断" class="header-anchor">#</a> 对象相等判断</h2> <h3 id="和equals的区别"><a href="#和equals的区别" class="header-anchor">#</a> ==和equals的区别</h3> <ul><li><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</li> <li><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
<ul><li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li> <li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li> <li>举个例子：</li></ul></li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> test1 <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a 为一个引用</span>
        <span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;ab&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b为另一个引用,对象的内容一样</span>
        <span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 放在常量池中</span>
        <span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 从常量池中查找</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>aa <span class="token operator">==</span> bb<span class="token punctuation">)</span> <span class="token comment">// true</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;aa==bb&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token comment">// false，非同一对象</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;a==b&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;aEQb&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">42</span> <span class="token operator">==</span> <span class="token number">42.0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// true</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ul><li>说明：
<ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li> <li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul></li></ul> <h3 id="hashcode与equals"><a href="#hashcode与equals" class="header-anchor">#</a> hashCode与equals</h3> <p><strong>hashCode作用：</strong></p> <ul><li>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</li> <li>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</li></ul> <p><strong>hashCode意义</strong>：</p> <blockquote><p>以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</p> <ul><li>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不的话，就会重新散列到其他位置。。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</li></ul></blockquote> <p><strong>hashCode()与equals()的相关规定：</strong></p> <ul><li>如果两个对象相等，则hashcode一定也是相同的</li> <li>两个对象相等，对两个对象分别调用equals方法都返回true</li> <li>两个对象有相同的hashcode值，它们也不一定是相等的</li></ul> <p>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</p> <h2 id="io流"><a href="#io流" class="header-anchor">#</a> IO流</h2> <h3 id="java中io流类型"><a href="#java中io流类型" class="header-anchor">#</a> Java中IO流类型</h3> <ul><li>按照流的流向分，可以分为输入流和输出流</li> <li>按照操作单元划分，可以划分字节流和字符流</li> <li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li> <li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul> <p><strong>按照操作方式分类结构图：</strong></p> <h3 id="bio-nio-aio的区别"><a href="#bio-nio-aio的区别" class="header-anchor">#</a> BIO，NIO，AIO的区别</h3> <ul><li>简答
<ul><li><strong>BIO</strong>：<strong>Block IO 同步阻塞式 IO</strong>，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li> <li><strong>NIO</strong>：<strong>Non IO 同步非阻塞 IO</strong>，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li> <li><strong>AIO</strong>：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了**异步非堵塞 IO **，异步 IO 的操作基于事件和回调机制。</li></ul></li> <li>详细回答
<ul><li>BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li> <li>NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Nonblocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li> <li>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。</li></ul></li></ul> <h2 id="反射"><a href="#反射" class="header-anchor">#</a> 反射</h2> <h3 id="反射机制"><a href="#反射机制" class="header-anchor">#</a> 反射机制</h3> <ul><li>JAVA反射机制是<strong>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法</strong>；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li> <li>静态编译和动态编译
<ul><li>静态编译：在编译时确定类型，绑定对象</li> <li>动态编译：运行时确定类型，绑定对象</li></ul></li> <li>反射机制的优缺点：
<ul><li>**优点：**运行期类型的判断，动态加载类，提高代码灵活度。</li> <li>**缺点：**性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li></ul></li></ul> <h3 id="反射机制的应用场景"><a href="#反射机制的应用场景" class="header-anchor">#</a> 反射机制的应用场景</h3> <ol><li>我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；</li> <li>Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：</li> <li>将程序内所有 XML 或 Properties 配置文件加载入内存中;</li> <li>Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息;</li> <li>使用反射机制，根据这个字符串获得某个类的Class实例;</li> <li>动态配置实例的属性</li></ol> <h3 id="java获取反射的三种方法"><a href="#java获取反射的三种方法" class="header-anchor">#</a> Java获取反射的三种方法</h3> <ol><li>通过new对象实现反射机制</li> <li>通过路径实现反射机制</li> <li>通过类名实现反射机制</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
  <span class="token class-name">String</span> name<span class="token punctuation">;</span>
  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> sex<span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">float</span> score<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Get</span> <span class="token punctuation">{</span>
  <span class="token comment">//获取反射机制三种方式</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
    <span class="token comment">//方式一(通过建立对象)</span>
    <span class="token class-name">Student</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Class</span> classobj1 <span class="token operator">=</span> stu<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classobj1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//方式二（所在通过路径-相对路径）</span>
    <span class="token class-name">Class</span> classobj2 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;fanshe.Student&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classobj2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//方式三（通过类名）</span>
    <span class="token class-name">Class</span> classobj3 <span class="token operator">=</span> <span class="token class-name">Student</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classobj3<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="string类"><a href="#string类" class="header-anchor">#</a> String类</h2> <h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="header-anchor">#</a> 字符型常量和字符串常量的区别</h3> <ol><li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li> <li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li> <li>占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li></ol> <h3 id="string的特性"><a href="#string的特性" class="header-anchor">#</a> String的特性</h3> <ul><li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li> <li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li> <li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ul> <h3 id="string-stringbuilder和stringbuffer"><a href="#string-stringbuilder和stringbuffer" class="header-anchor">#</a> String，StringBuilder和StringBuffer</h3> <p><strong>可变性：</strong></p> <ul><li>String类中使用字符串数组保存字符串（private final char value[]）所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串(char[] value)，所以说这两种对象保存的字符串数据都是可变的。</li></ul> <p><strong>线程安全性：</strong></p> <ul><li>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li></ul> <p><strong>性能：</strong></p> <ul><li>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#java概述" class="sidebar-link reco-side-java概述" data-v-b57cc07c>Java概述</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#何为编程" class="sidebar-link reco-side-何为编程" data-v-b57cc07c>何为编程</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#什么是java" class="sidebar-link reco-side-什么是java" data-v-b57cc07c>什么是Java</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#jdk1-5之后的三大版本" class="sidebar-link reco-side-jdk1-5之后的三大版本" data-v-b57cc07c>jdk1.5之后的三大版本</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#jdk和jre和jvm的区别" class="sidebar-link reco-side-jdk和jre和jvm的区别" data-v-b57cc07c>JDK和JRE和JVM的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#什么是跨平台性-原理是什么" class="sidebar-link reco-side-什么是跨平台性-原理是什么" data-v-b57cc07c>什么是跨平台性？原理是什么</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#java语言有哪些特点" class="sidebar-link reco-side-java语言有哪些特点" data-v-b57cc07c>Java语言有哪些特点</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#什么是字节码-采用字节码的最大好处是什么" class="sidebar-link reco-side-什么是字节码-采用字节码的最大好处是什么" data-v-b57cc07c>什么是字节码？采用字节码的最大好处是什么</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#什么是java程序的主类-应用程序和小程序的主类有何不同" class="sidebar-link reco-side-什么是java程序的主类-应用程序和小程序的主类有何不同" data-v-b57cc07c>什么是Java程序的主类？应用程序和小程序的主类有何不同？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#java应用程序与小程序之间有那些差别" class="sidebar-link reco-side-java应用程序与小程序之间有那些差别" data-v-b57cc07c>Java应用程序与小程序之间有那些差别？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#java和c-的区别" class="sidebar-link reco-side-java和c-的区别" data-v-b57cc07c>Java和C++的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#oracle-jdk-和-openjdk-的对比" class="sidebar-link reco-side-oracle-jdk-和-openjdk-的对比" data-v-b57cc07c>Oracle JDK 和 OpenJDK 的对比</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#面向对象" class="sidebar-link reco-side-面向对象" data-v-b57cc07c>面向对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#什么是面向对象" class="sidebar-link reco-side-什么是面向对象" data-v-b57cc07c>什么是面向对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#面向对象和面向过程的区别" class="sidebar-link reco-side-面向对象和面向过程的区别" data-v-b57cc07c>面向对象和面向过程的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#面向对象的三大特性" class="sidebar-link reco-side-面向对象的三大特性" data-v-b57cc07c>面向对象的三大特性</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#面向对象的五大基本原则" class="sidebar-link reco-side-面向对象的五大基本原则" data-v-b57cc07c>面向对象的五大基本原则</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#值传递和引用传递" class="sidebar-link reco-side-值传递和引用传递" data-v-b57cc07c>值传递和引用传递</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#接口和抽象类的区别" class="sidebar-link reco-side-接口和抽象类的区别" data-v-b57cc07c>接口和抽象类的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#父类的静态方法能否被子类重写" class="sidebar-link reco-side-父类的静态方法能否被子类重写" data-v-b57cc07c>父类的静态方法能否被子类重写</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#什么是不可变对象" class="sidebar-link reco-side-什么是不可变对象" data-v-b57cc07c>什么是不可变对象</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#静态变量和实例变量的区别" class="sidebar-link reco-side-静态变量和实例变量的区别" data-v-b57cc07c>静态变量和实例变量的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#重写和重载的区别" class="sidebar-link reco-side-重写和重载的区别" data-v-b57cc07c>重写和重载的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#基本数据类型" class="sidebar-link reco-side-基本数据类型" data-v-b57cc07c>基本数据类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#java基本数据类型" class="sidebar-link reco-side-java基本数据类型" data-v-b57cc07c>Java基本数据类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#switch用法" class="sidebar-link reco-side-switch用法" data-v-b57cc07c>switch用法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#math-round用法" class="sidebar-link reco-side-math-round用法" data-v-b57cc07c>Math.round用法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#float用法" class="sidebar-link reco-side-float用法" data-v-b57cc07c>float用法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#short用法" class="sidebar-link reco-side-short用法" data-v-b57cc07c>short用法</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#访问修饰符" class="sidebar-link reco-side-访问修饰符" data-v-b57cc07c>访问修饰符</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#关键字" class="sidebar-link reco-side-关键字" data-v-b57cc07c>关键字</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#final-finally和finalize区别" class="sidebar-link reco-side-final-finally和finalize区别" data-v-b57cc07c>final，finally和finalize区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#this用法" class="sidebar-link reco-side-this用法" data-v-b57cc07c>this用法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#super用法" class="sidebar-link reco-side-super用法" data-v-b57cc07c>super用法</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#this与super区别" class="sidebar-link reco-side-this与super区别" data-v-b57cc07c>this与super区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#static的作用" class="sidebar-link reco-side-static的作用" data-v-b57cc07c>static的作用</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#内部类" class="sidebar-link reco-side-内部类" data-v-b57cc07c>内部类</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#什么是内部类" class="sidebar-link reco-side-什么是内部类" data-v-b57cc07c>什么是内部类</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#内部类的种类" class="sidebar-link reco-side-内部类的种类" data-v-b57cc07c>内部类的种类</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#内部类优点和应用场景" class="sidebar-link reco-side-内部类优点和应用场景" data-v-b57cc07c>内部类优点和应用场景</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#局部内部类和匿名内部类访问局部变量的时候-为什么变量必须要加上final" class="sidebar-link reco-side-局部内部类和匿名内部类访问局部变量的时候-为什么变量必须要加上final" data-v-b57cc07c>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#重写与重载" class="sidebar-link reco-side-重写与重载" data-v-b57cc07c>重写与重载</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#对象相等判断" class="sidebar-link reco-side-对象相等判断" data-v-b57cc07c>对象相等判断</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#和equals的区别" class="sidebar-link reco-side-和equals的区别" data-v-b57cc07c>==和equals的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#hashcode与equals" class="sidebar-link reco-side-hashcode与equals" data-v-b57cc07c>hashCode与equals</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#io流" class="sidebar-link reco-side-io流" data-v-b57cc07c>IO流</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#java中io流类型" class="sidebar-link reco-side-java中io流类型" data-v-b57cc07c>Java中IO流类型</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#bio-nio-aio的区别" class="sidebar-link reco-side-bio-nio-aio的区别" data-v-b57cc07c>BIO，NIO，AIO的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#反射" class="sidebar-link reco-side-反射" data-v-b57cc07c>反射</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#反射机制" class="sidebar-link reco-side-反射机制" data-v-b57cc07c>反射机制</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#反射机制的应用场景" class="sidebar-link reco-side-反射机制的应用场景" data-v-b57cc07c>反射机制的应用场景</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#java获取反射的三种方法" class="sidebar-link reco-side-java获取反射的三种方法" data-v-b57cc07c>Java获取反射的三种方法</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#string类" class="sidebar-link reco-side-string类" data-v-b57cc07c>String类</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#字符型常量和字符串常量的区别" class="sidebar-link reco-side-字符型常量和字符串常量的区别" data-v-b57cc07c>字符型常量和字符串常量的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#string的特性" class="sidebar-link reco-side-string的特性" data-v-b57cc07c>String的特性</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/Java/Java%E5%9F%BA%E7%A1%80.html#string-stringbuilder和stringbuffer" class="sidebar-link reco-side-string-stringbuilder和stringbuffer" data-v-b57cc07c>String，StringBuilder和StringBuffer</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.b6f48787.js" defer></script><script src="/assets/js/7.ec9bc4d0.js" defer></script><script src="/assets/js/2.0c7886bd.js" defer></script><script src="/assets/js/1.8f3833ee.js" defer></script><script src="/assets/js/39.991d6637.js" defer></script>
  </body>
</html>
